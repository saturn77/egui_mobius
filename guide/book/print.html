<!DOCTYPE HTML>
<html lang="en" class="dark sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>egui_mobius User Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "dark";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('dark')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">egui_mobius User Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="welcome"><a class="header" href="#welcome">Welcome</a></h1>
<p><code>egui_mobius</code> is a framework for  creating modular egui_application.</p>
<p><img src="../../assets/egui_mobius_logo.png" alt="alt text" /></p>
<h2 id="landscape-of-rust-gui"><a class="header" href="#landscape-of-rust-gui">Landscape of Rust GUI</a></h2>
<p>When evaluating GUI frameworks in Rust, there are several key features to consider:</p>
<ul>
<li><strong>Ease of Use</strong>: How easy is it to get started and build applications?</li>
<li><strong>Performance</strong>: How well does the framework perform, especially for complex and dynamic UIs?</li>
<li><strong>Cross-Platform Support</strong>: Does the framework support multiple operating systems?</li>
<li><strong>Widget Availability</strong>: Does the framework provide a rich set of widgets for building UIs?</li>
<li><strong>Community and Ecosystem</strong>: Is there a strong community and ecosystem around the framework?</li>
</ul>
<p>Based on these criteria, <code>egui</code> has emerged as a top contender for desktop applications. It offers a well-designed architecture, compelling widgets, and a strong focus on performance and ease of use. The immediate mode nature of <code>egui</code> allows for highly responsive and interactive user interfaces, making it a powerful tool for building modern desktop applications.</p>
<h2 id="egui"><a class="header" href="#egui">egui</a></h2>
<p>Building scalable UI applications with <code>egui</code> can be challenging due to its immediate mode nature. Immediate mode GUI frameworks redraw the entire UI every frame, which can make managing complex state and optimizing performance more difficult. However, <code>egui</code> offers compelling widgets and a well-designed architecture that make it a powerful tool for creating responsive and interactive user interfaces. By leveraging <code>egui_mobius</code>, developers can overcome some of these challenges by using a modular approach and integrating threading and concurrency features.</p>
<h3 id="separation-of-concerns"><a class="header" href="#separation-of-concerns">Separation of Concerns</a></h3>
<p>One of the primary mechanisms for making a GUI modular is the separation of concerns between the backend and frontend. This approach allows developers to independently develop and maintain the logic and presentation layers of the application. However, <code>egui</code> at present does not inherently support this separation well, which can lead to tightly coupled code and difficulties in managing complex applications.</p>
<p><code>egui_mobius</code> addresses this by providing a clear separation between the backend and frontend. The backend handles the application logic, state management, and processing of events, while the frontend is responsible for rendering the user interface and handling user interactions. This separation is akin to a M√∂bius strip, where the backend and frontend are two sides of a single surface, continuously interacting and updating each other.</p>
<p>By adopting this modular approach, <code>egui_mobius</code> enables developers to build scalable and maintainable applications, leveraging the strengths of both <code>egui</code> and the Mobius framework.</p>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<p>The main goal of egui_mobius is <strong>modularity facilitating design reuse and scalability.</strong></p>
<p>Additional goals</p>
<ul>
<li>Create a framework that facilitates using threading and concurrency features</li>
<li>Create consistent design patterns for egui applications</li>
<li>Provide integrated tooling for scaffolding new projects</li>
<li>Provide stateful widgets and components</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation--dependencies"><a class="header" href="#installation--dependencies">Installation &amp; Dependencies</a></h1>
<p>egui_mobius runs with the 2024 edition of Rust.</p>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>For a typical egui_mobius project, the dependencies are :</p>
<ul>
<li>egui</li>
<li>eframe</li>
<li>serde</li>
<li>egui_plot (for plotting / visualization applications)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>The egui_mobius library is designed to integrate the egui GUI library with the Mobius framework, enabling efficient and responsive user interfaces by leveraging Mobius's signal-slot mechanism for message passing and state management. Here are some key points about its design architecture:</p>
<h2 id="key-components"><a class="header" href="#key-components">Key Components</a></h2>
<ol>
<li>
<p>Signals and Slots</p>
<p><strong>Signals</strong> send messages or events from one part of the application to another, using a channel / queue.</p>
<p><strong>Slots</strong> act as receivers for signals, processing the received messages or events on the other end of the channel. Slots alsoo spin
up their own thread, which is mentioned in more detail in the <a href="signals_slots.html">Signals &amp; Slots</a> section.</p>
</li>
<li>
<p>Data Types</p>
<p>A <strong>Value<T></strong> is a thread-safe wrapper around shared data, allowing safe concurrent access and modification.</p>
<p>An <strong>Edge<T></strong> Represents a value that can change over time, with methods to track changes.</p>
</li>
<li>
<p>Event Types</p>
<p>Custom event types are defined to represent different kinds of messages or commands that can be sent between the UI and backend.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Define event types
#[derive(Debug, Clone)]
enum EventType {
    Foo { id: usize, message: String },
    Bar { id: usize, message: String },
    // Other event types...
}

// Define processed event types
#[derive(Debug, Clone)]
enum ProcessedType {
    Foo { id: usize, message: String },
    Bar { id: usize, message: String },
    // Other processed event types...
}
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<ol>
<li>
<p>Separation of Concerns</p>
<p>The UI and backend logic are separated, with the UI sending events to the backend and the backend processing these events and sending updates back to the UI. This facilitates a command architecture design
pattern of</p>
<ul>
<li>main.rs - declare signals,slots, <code>backend_consumer_thread</code></li>
<li>ui_app.rs - holds <code>UiApp</code> &amp; <code>impl eframe::App for UiApp</code></li>
<li>backend.rs - holds <code>fn backend_consumer_thread</code></li>
</ul>
</li>
<li>
<p>Thread Safety</p>
<p>Shared data is wrapped in thread-safe types (<code>Value&lt;T&gt;</code>, <code>Edge&lt;T&gt;</code>) to ensure safe concurrent access.</p>
</li>
<li>
<p>Reactive Updates</p>
<p>The UI updates reactively based on events received from the backend, ensuring efficient and responsive interfaces.</p>
</li>
</ol>
<h2 id="example-workflow"><a class="header" href="#example-workflow">Example Workflow</a></h2>
<ol>
<li>
<p>UI Interaction:</p>
<p>The user interacts with the UI, triggering events (e.g., button clicks, slider changes).</p>
</li>
<li>
<p>Event Handling:</p>
<p>These events are sent as signals to the backend for processing.</p>
</li>
<li>
<p>Backend Processing:</p>
<p>The backend processes the events, updates the shared state, and sends processed events back to the UI.</p>
</li>
<li>
<p>UI Update:</p>
<p>The UI receives the processed events and updates the interface accordingly.</p>
<pre><pre class="playground"><code class="language-rust">// UI Application struct
struct UiApp {
    logger_text: Value&lt;String&gt;,
    signal_to_backend: Signal&lt;EventType&gt;,
    slot_on_uiapp: Slot&lt;ProcessedType&gt;,
    update_needed: Value&lt;bool&gt;,
    // Other fields...
}

// Implement eframe::App for UiApp
impl eframe::App for UiApp {
    fn update(&amp;mut self, ctx: &amp;egui::Context, _frame: &amp;mut eframe::Frame) {
        // UI update logic...
    }
}

// Backend consumer thread
fn backend_consumer_thread(
    logger_text: Value&lt;String&gt;,
    messages: Value&lt;VecDeque&lt;String&gt;&gt;,
    update_needed: Value&lt;bool&gt;,
    mut slot: Slot&lt;EventType&gt;,
    slot_on_uiapp: Signal&lt;ProcessedType&gt;,
) {
    slot.start({
        let messages_clone = Value::clone(&amp;messages);
        let update_needed_clone = Value::clone(&amp;update_needed);
        let logger_text_clone = Value::clone(&amp;logger_text);
        move |event| {
            // Event processing logic...
        }
    });
}

// Main function
fn main() {
    // Initialization and setup...
}</code></pre></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signals--slots"><a class="header" href="#signals--slots">Signals &amp; Slots</a></h1>
<p>The use of Signals and Slots allows for sending data between threads in an
application, and is the primary method for achieving the main goal of egui_mobius
which is modularity facilitating design reuse and scalability.</p>
<p>There is a
factory method for creating a signal/slot pair, often useful for use in main.rs
when the application is setting up the signals and slots for the application.</p>
<h2 id="signalslot-example"><a class="header" href="#signalslot-example">Signal/Slot Example</a></h2>
<p>Consider the ui_refresh_events example main.rs to see the declaration and use
of a signal/slot pairs.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    env_logger::init();

    let messages = Value::new(VecDeque::new());
    let update_needed = Value::new(false);
    let logger_text = Value::new("Welcome to egui_mobius ui_refresh_events example ....\n".to_string());

    let (signal_to_backend, slot_to_backend) = factory::create_signal_slot::&lt;EventType&gt;(1);
    let (slot_on_uiapp, slot_from_backend) = factory::create_signal_slot::&lt;ProcessedType&gt;(1);

    backend_consumer_thread(
        Value::clone(&amp;logger_text),
        Value::clone(&amp;messages),
        Value::clone(&amp;update_needed),
        slot_to_backend,
        slot_on_uiapp.clone(),
    );

    let options = eframe::NativeOptions {
        viewport: egui::ViewportBuilder::default()
            .with_titlebar_buttons_shown(true)
            .with_min_inner_size((650.0, 700.0))
            .with_resizable(true)
            .with_max_inner_size((650.0, 700.0)),
        ..Default::default()
    };

    if let Err(e) = eframe::run_native(
        "egui_mobius - UI Refresh Events Example",
        options,
        Box::new(|_cc| Ok(Box::new(UiApp::new(
            signal_to_backend,
            slot_from_backend,
            update_needed,
        )))),
    ) {
        eprintln!("Failed to run eframe: {:?}", e);
    }
}</code></pre></pre>
<h3 id="design-pattern"><a class="header" href="#design-pattern">Design Pattern</a></h3>
<p>Note that the main.rs file length is rather compact. There is a consistent
design pattern in several of the example that :</p>
<p>The <code>pattern_mobius_main</code> typically does:</p>
<ol>
<li>Declares signal/slot pairs for the application in main.rs</li>
<li>Declares backend process thread in main.rs</li>
<li>Sets options for eframe</li>
<li>Runs the actual eframe/egui application</li>
</ol>
<h2 id="slot-core-functionality"><a class="header" href="#slot-core-functionality">Slot Core Functionality</a></h2>
<p>The Slot is more sophisticated the Signal, as it sets up it's own thread. The
code below is from the core of egui_mobius, and note the <em>msg_or_event</em> syntax
for the argument to the handler. The reason for this is that the Slot can be
placed on a backend consumer thread, or and UiApplication (UiApp) thread. The
syntax is there to support both use cases, where a Slot may take in an event
when it's part of the primary background consumer thread, and where it may take
in a processed event on the UiApp side in which case it's receiving a message.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T&gt; Slot&lt;T&gt;
where
    T: Send + 'static + Clone,
{
    /// Create a new slot with the given receiver and sequence ID.
    pub fn new(receiver: Receiver&lt;T&gt;, id_sequence : Option&lt;usize&gt;) -&gt; Self {
        Slot {
            receiver: Arc::new(Mutex::new(receiver)),
            sequence: id_sequence.unwrap_or(0),
        }
    }
    /// Start the slot in a separate thread.
    pub fn start&lt;F&gt;(&amp;mut self, mut handler: F)
    where
        F: FnMut(T) + Send + 'static,
    {
        let receiver = Arc::clone(&amp;self.receiver);
        thread::spawn(move || {
            let receiver = receiver.lock().unwrap();
            for msg_or_event in receiver.iter() {
                handler(msg_or_event);
            }
        });
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="egui_mobius---ui-refresh-events-example"><a class="header" href="#egui_mobius---ui-refresh-events-example">egui_mobius - UI Refresh Events Example</a></h1>
<h2 id="-running-the-example"><a class="header" href="#-running-the-example">üõ†Ô∏è Running the Example</a></h2>
<p>Ensure you have <strong>Rust and Cargo installed</strong>, then run:</p>
<pre><code class="language-sh">cargo run -p ui_refresh_events
</code></pre>
<h2 id="-why-this-example-matters"><a class="header" href="#-why-this-example-matters">üöÄ Why This Example Matters</a></h2>
<p>This is currently the <strong>primary example</strong> for <code>egui_mobius</code>, showcasing:</p>
<ul>
<li><strong>Best practices for using signals and slots.</strong></li>
<li><strong>Proper separation of frontend and backend logic.</strong></li>
<li><strong>Efficient event-driven UI updates.</strong></li>
<li><strong>Maintainable, scalable code</strong></li>
<li><strong>Optimized logging and UI responsiveness.</strong></li>
</ul>
<h2 id="-overview"><a class="header" href="#-overview">üìñ Overview</a></h2>
<p>This example, <code>ui_refresh_events</code>, demonstrates event-driven UI updates using <code>egui_mobius</code>, where signals and slots facilitate communication between the frontend (UI application) and backend (event consumer thread).</p>
<p>It showcases:</p>
<ul>
<li>Separation of frontend (UI) and backend (processing logic).</li>
<li>Bi-directional communication** between UI and backend.</li>
<li>Flexible Event handling</li>
<li>Event-based UI updates</li>
<li>Usage of egui_mobius types** <code>Value&lt;T &gt;</code> &amp;&amp; <code>Edge&lt;T&gt;</code></li>
<li>Ergonomic hanling of <code>Arc&lt;Mutex&lt;T&gt;&gt;</code> and improved event detection.</li>
<li>Efficient logging system that dynamically updates in response to backend events.</li>
</ul>
<h2 id="-architecture"><a class="header" href="#-architecture">‚ö° Architecture</a></h2>
<p>This example follows a structured <strong>frontend-backend model</strong> using **signals and slots for inter-thread communication.</p>
<h3 id="-frontend-uiapp"><a class="header" href="#-frontend-uiapp">üìà Frontend (<code>UiApp</code>)</a></h3>
<ul>
<li>Sends events** to the backend via <code>Signal&lt;EventType&gt;</code>.</li>
<li>Receives processed events** via <code>Slot&lt;ProcessedType&gt;</code>.</li>
<li>UI updates only when new events are received
(avoiding unnecessary redraws).</li>
<li>Provides user interaction elements:
<ul>
<li>Buttons (<code>Foo</code>, <code>Bar</code>, <code>Application Commands</code>).</li>
<li>Slider with real-time updates.</li>
<li>ComboBox for selection-based events.</li>
<li>Logger system to track event flow.</li>
</ul>
</li>
</ul>
<h3 id="-backend-backend_consumer_thread"><a class="header" href="#-backend-backend_consumer_thread">üë®‚Äçüíª Backend (<code>backend_consumer_thread</code>)</a></h3>
<ul>
<li>Receives events from the UI via <code>Slot&lt;EventType&gt;</code>.</li>
<li>Processes events and sends responses back using <code>Signal&lt;ProcessedType&gt;</code>.</li>
<li>Handles application logic:
<ul>
<li><code>Foo</code> and <code>Bar</code> events.</li>
<li>Slider value updates.</li>
<li>Combo box selection tracking.</li>
<li>System-level commands (<code>Clear Logger</code>, <code>OS Info</code>, <code>Version Info</code>, <code>Shutdown</code>).</li>
</ul>
</li>
</ul>
<h2 id="-code-structure"><a class="header" href="#-code-structure">üìÇ Code Structure</a></h2>
<pre><code>examples/ui_refresh_events/
‚îÇ‚îÄ‚îÄ main.rs          # Main entry point defining frontend and backend logic
‚îÇ‚îÄ‚îÄ README.md        # This file
‚îÇ‚îÄ‚îÄ Cargo.toml       # Dependencies and build configurations
</code></pre>
<h2 id="key-components-1"><a class="header" href="#key-components-1">Key Components</a></h2>
<h3 id="-event-system-eventtype--processedtype"><a class="header" href="#-event-system-eventtype--processedtype">üî¢ Event System (<code>EventType</code> &amp; <code>ProcessedType</code>)</a></h3>
<p>Defines <strong>all possible events</strong>, ensuring structured communication.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
enum EventType {
    Foo { id: usize, message: String },
    Bar { id: usize, message: String },
    Slider(usize),
    Combo { _id: usize, message: String },
    ApplicationCommand(String),
}

#[derive(Debug, Clone)]
enum ProcessedType {
    Foo    { id: usize, message: String   },
    Bar    { id: usize, message: String   },
    Slider { message: String              },
    _Combo  { _id: usize, message: String  },    
    _ApplicationCommand { message : String },
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h3 id="-frontend---uiapp"><a class="header" href="#-frontend---uiapp">üõ†Ô∏è Frontend - <code>UiApp</code></a></h3>
<p>Manages the UI and sends/receives events.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct UiApp {
    logger_text         : Value&lt;String&gt;,
    signal_to_backend   : Signal&lt;EventType&gt;,  
    slot_on_uiapp       : Slot&lt;ProcessedType&gt;,  
    update_needed       : Value&lt;bool&gt;,
    slider_value        : Value&lt;Edge&lt;usize&gt;&gt;,
    combo_value         : Value&lt;Edge&lt;String&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h3 id="-backend---backend_consumer_thread"><a class="header" href="#-backend---backend_consumer_thread">üõ†Ô∏è Backend - <code>backend_consumer_thread</code></a></h3>
<p>Processes UI events and sends responses.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn backend_consumer_thread(
    logger_text         : Value&lt;String&gt;,
    messages            : Value&lt;VecDeque&lt;String&gt;&gt;,
    update_needed       : Value&lt;bool&gt;,
    mut slot            : Slot&lt;EventType&gt;,         // incoming from UiApp
    slot_on_uiapp       : Signal&lt;ProcessedType&gt;,   // outgoing to UiApp
) {
    slot.start({
        move |event| {
            let log_msg = match &amp;event {
                EventType::Foo { id, message } =&gt; {
                    format!("Backend processed Foo event [{}]: {}", id, message)
                },
                EventType::Bar { id, message } =&gt; {
                    format!("Backend processed Bar event [{}]: {}", id, message)
                },
                EventType::Slider(value) =&gt; {
                    format!("Backend processed Slider value: {}", value)
                },
                _ =&gt; "Unknown event".to_string(),
            };
            slot_on_uiapp.send(ProcessedType::_ApplicationCommand { message: log_msg.clone() }).unwrap();
        }
    });
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="-signals--slots-workflow"><a class="header" href="#-signals--slots-workflow">üõ†Ô∏è Signals &amp; Slots Workflow</a></h2>
<div class="table-wrapper"><table><thead><tr><th><strong>Step</strong></th><th><strong>Action</strong></th></tr></thead><tbody>
<tr><td>1Ô∏è‚É£ User interacts with UI</td><td><strong>Event (e.g., <code>Slider</code> change, <code>Foo</code> button click) is sent to backend</strong> via <code>Signal&lt;EventType&gt;</code></td></tr>
<tr><td>2Ô∏è‚É£ Backend processes event</td><td><strong>Backend logs event and sends a response to UI</strong> via <code>Signal&lt;ProcessedType&gt;</code></td></tr>
<tr><td>3Ô∏è‚É£ UI receives processed event</td><td><strong>Logger updates, UI refreshes only if needed</strong></td></tr>
</tbody></table>
</div>
<h2 id="-license"><a class="header" href="#-license">üìö License</a></h2>
<p>This example is part of the <code>egui_mobius</code> project and is available under the <strong>MIT License</strong>.</p>
<h3 id="-get-started--contribute"><a class="header" href="#-get-started--contribute">üöÄ Get Started &amp; Contribute</a></h3>
<p>Contributions are welcome! If you find an issue or have an idea for improvement, feel free to submit a PR.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="egui_mobius---real-time-plotting-example"><a class="header" href="#egui_mobius---real-time-plotting-example">egui_mobius - Real-Time Plotting Example</a></h1>
<h2 id="-running-the-example-1"><a class="header" href="#-running-the-example-1">üõ†Ô∏è Running the Example</a></h2>
<p>Ensure you have <strong>Rust and Cargo installed</strong>, then run:</p>
<pre><code class="language-sh">cargo run -p realtime_plot
</code></pre>
<h2 id="-why-this-example-matters-1"><a class="header" href="#-why-this-example-matters-1">üöÄ Why This Example Matters</a></h2>
<p>This example serves as a reference implementation for real-time data visualization in <code>egui_mobius</code>.</p>
<ul>
<li><strong>Best practices for using signals and slots, producer-consumer models.</strong></li>
<li><strong>Proper separation of frontend and backend logic.</strong></li>
<li><strong>Maintainable, scalable code.</strong></li>
<li><strong>Optimized data handling using FIFO history buffers.</strong></li>
<li><strong>Scalable design for other embedded applications.</strong></li>
</ul>
<h2 id="-overview-1"><a class="header" href="#-overview-1">üìñ Overview</a></h2>
<p>This example shows how to use egui_mobius to provide the framework for an egui application that uses <code>egui_plot</code> crate to perform real time plotting. Usually the real
time data would come from a serial-usb or ethernet connected device, but in this example
there is a background producer thread to create the data.</p>
<p>This example is easily extended to developing a range of applications, for example, a
typical serial monitor that would be communicating with a micro-controller or fpga.</p>
<h2 id="-architecture-1"><a class="header" href="#-architecture-1">‚ö° Architecture</a></h2>
<p>This example follows a structured <strong>frontend-backend model</strong> using <strong>signals and slots</strong> for inter-thread communication.</p>
<h3 id="-frontend-app"><a class="header" href="#-frontend-app">üéõÔ∏è Frontend (<code>App</code>)</a></h3>
<ul>
<li>Handles UI rendering and user input (sliders for temperature control).</li>
<li>Sends updated temperature values to the backend via <code>Signal&lt;Event&gt;</code>.</li>
<li>Receives processed data updates from the backend via <code>Slot&lt;Event&gt;</code>.</li>
<li>Plots real-time temperature data using <code>egui_plot</code> with a legend.</li>
</ul>
<h3 id="-backend-producer_thread--consumer_thread"><a class="header" href="#-backend-producer_thread--consumer_thread">üîÑ Backend (<code>producer_thread</code> &amp; <code>consumer_thread</code>)</a></h3>
<ul>
<li>Producer Thread generates temperature data every second.</li>
<li>Consumer Thread processes incoming updates and manages the <strong>FIFO buffer</strong>.</li>
<li>Maintains historical temperature data** (last 300 values).</li>
</ul>
<h2 id="-code-structure-1"><a class="header" href="#-code-structure-1">üìÇ Code Structure</a></h2>
<pre><code>examples/real_time_temperature/
‚îÇ‚îÄ‚îÄ main.rs          # Main entry point defining frontend and backend logic
‚îÇ‚îÄ‚îÄ README.md        # This file
‚îÇ‚îÄ‚îÄ Cargo.toml       # Dependencies and build configurations
</code></pre>
<h2 id="-key-components"><a class="header" href="#-key-components">üåü Key Components</a></h2>
<h3 id="-event-system-event"><a class="header" href="#-event-system-event">üî¢ Event System (<code>Event</code>)</a></h3>
<p>Defines <strong>temperature update messages</strong>, ensuring structured communication.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone)]
enum Event {
    DataUpdated { inlet: f64, exhaust: f64, ambient: f64 },
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h3 id="-fabric-context-fabric"><a class="header" href="#-fabric-context-fabric">üõ†Ô∏è Fabric Context (<code>Fabric</code>)</a></h3>
<p>Stores <strong>shared application data</strong>, acting as a structured data layer for UI updates.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Fabric {
    inlet_temp      : Value&lt;f64&gt;,
    exhaust_temp    : Value&lt;f64&gt;,
    ambient_temp    : Value&lt;f64&gt;,
    inlet_history   : Value&lt;Vec&lt;f64&gt;&gt;,
    exhaust_history : Value&lt;Vec&lt;f64&gt;&gt;,
    ambient_history : Value&lt;Vec&lt;f64&gt;&gt;,
    y_bounds        : Value&lt;(f64, f64)&gt;,
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h3 id="-frontend---app"><a class="header" href="#-frontend---app">üõ†Ô∏è Frontend - <code>App</code></a></h3>
<p>Manages UI interactions and plotting.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct App {
    fabric_data  : Fabric,
    ui_signal    : Signal&lt;Event&gt;,
    ui_slot      : Slot&lt;Event&gt;,
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h3 id="-backend---producer_thread"><a class="header" href="#-backend---producer_thread">üõ†Ô∏è Backend - <code>producer_thread</code></a></h3>
<p>Generates temperature data every second.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn producer_thread(signal: Signal&lt;Event&gt;, fabric_data: &amp;Fabric) {
    thread::spawn(move || {
        loop {
            let inlet_val = *fabric_data.inlet_temp.lock().unwrap();
            let exhaust_val = *fabric_data.exhaust_temp.lock().unwrap();
            let ambient_val = *fabric_data.ambient_temp.lock().unwrap();

            if signal.send(Event::DataUpdated { inlet: inlet_val, exhaust: exhaust_val, ambient: ambient_val }).is_err() {
                eprintln!("Failed to send data update from producer.");
            }

            thread::sleep(Duration::from_secs(1));
        }
    });
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h3 id="-backend---consumer_thread"><a class="header" href="#-backend---consumer_thread">üõ†Ô∏è Backend - <code>consumer_thread</code></a></h3>
<p>Processes received temperature updates and manages history.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn consumer_thread(mut slot: Slot&lt;Event&gt;, fabric_data: &amp;Fabric) {
    slot.start(move |event| {
        let Event::DataUpdated { inlet: new_inlet, exhaust: new_exhaust, ambient: new_ambient } = event;

        *fabric_data.inlet_temp.lock().unwrap() = new_inlet;
        *fabric_data.exhaust_temp.lock().unwrap() = new_exhaust;
        *fabric_data.ambient_temp.lock().unwrap() = new_ambient;

        append_and_maintain_fifo!(fabric_data.inlet_history.lock().unwrap(), new_inlet, 300);
        append_and_maintain_fifo!(fabric_data.exhaust_history.lock().unwrap(), new_exhaust, 300);
        append_and_maintain_fifo!(fabric_data.ambient_history.lock().unwrap(), new_ambient, 300);
    });
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h3 id="-real-time-plotting"><a class="header" href="#-real-time-plotting">üìä Real-Time Plotting</a></h3>
<p>The UI dynamically plots <strong>three temperature lines</strong> (inlet, exhaust, ambient) with <strong>color coding and a legend</strong>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Plot::new("temp_plot")
    .view_aspect(2.0)
    .legend(Legend::default())
    .show(ui, |plot_ui| {
        let inlet_points: PlotPoints = fabric_data.inlet_history.lock().unwrap()
            .iter().enumerate().map(|(i, &amp;y)| [i as f64, y]).collect();
        let exhaust_points: PlotPoints = fabric_data.exhaust_history.lock().unwrap()
            .iter().enumerate().map(|(i, &amp;y)| [i as f64, y]).collect();
        let ambient_points: PlotPoints = fabric_data.ambient_history.lock().unwrap()
            .iter().enumerate().map(|(i, &amp;y)| [i as f64, y]).collect();

        plot_ui.line(Line::new(inlet_points).name("Inlet Temp (¬∞C)").color(egui::Color32::RED));
        plot_ui.line(Line::new(exhaust_points).name("Exhaust Temp (¬∞C)").color(egui::Color32::BLUE));
        plot_ui.line(Line::new(ambient_points).name("Ambient Temp (¬∞C)").color(egui::Color32::GREEN));
    });
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="-signals--slots-workflow-1"><a class="header" href="#-signals--slots-workflow-1">üõ†Ô∏è Signals &amp; Slots Workflow</a></h2>
<div class="table-wrapper"><table><thead><tr><th><strong>Step</strong></th><th><strong>Action</strong></th></tr></thead><tbody>
<tr><td>1Ô∏è‚É£ User interacts with UI</td><td><strong>Updates inlet, exhaust, or ambient temperature via sliders.</strong></td></tr>
<tr><td>2Ô∏è‚É£ UI sends event to backend</td><td><strong><code>Signal&lt;Event&gt;::send(Event::DataUpdated { ... })</code></strong></td></tr>
<tr><td>3Ô∏è‚É£ Backend processes event</td><td><strong>Updates stored values and manages history.</strong></td></tr>
<tr><td>4Ô∏è‚É£ UI receives processed data</td><td><strong>Plots updated temperature trends.</strong></td></tr>
</tbody></table>
</div>
<h2 id="-license-1"><a class="header" href="#-license-1">üìö License</a></h2>
<p>This example is part of the <code>egui_mobius</code> project and is available under the <strong>MIT License</strong>.</p>
<h3 id="-get-started--contribute-1"><a class="header" href="#-get-started--contribute-1">üöÄ Get Started &amp; Contribute</a></h3>
<p>Contributions are welcome! If you find an issue or have an idea for improvement, feel free to submit a PR.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
